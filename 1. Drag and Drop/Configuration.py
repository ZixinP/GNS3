import json
import ipaddress
import os
import time

# 打开JSON文件并加载数据 nom de fichier ".json"
json_file=open("Configuration.json")
data=json.load(json_file)

# 初始化IP地址范围
start_subnet=ipaddress.IPv6Network(data['IPv6_range']['Physical']['start'])
#print(data['IPv6_range']['Physical']['start'])
#start_subnet=ipaddress.IPv6Network('2001:100:100:1::/64')
#end_subnet=ipaddress.IPv6Network('2001:200:100:255::/64')
end_subnet=ipaddress.IPv6Network(data['IPv6_range']['Physical']['end'])

# 存储IP地址的列表
#stockIP=[{'r1':[{'inter1':'ip@'},{'inter2':'ip@'}]},]
stockIPs=[]

# 根据起始和结束IP地址，生成子网地址
subnets = ipaddress.summarize_address_range(start_subnet.network_address, end_subnet.network_address)
i=0
#subnet=next(subnets)


# 分配IP地址到路由器 distribuer les @ aux routeurs
for router in data['routers']:
	stockIPs+=[{router['name']:[] }]
for link in data['links']:
	#for router in data['routers']:
	for stockIP in stockIPs:
		#print(link['source']['router'])
		for key in stockIP:
			#print(key)
			if key==link['source']['router'] :
				subnet1=next(subnets)
				address1=subnet1[1]
				address2=subnet1[2]
				#print(subnet1)
				#print(address1)
				#print(address2)
				#print(stockIP.keys())
				#print(stockIP[key])

				# 分配IP地址给目标路由器
				stockIP[key]+=[{link['source']['interface']:str(address1)}]
				for stock1 in stockIPs:
					for key1 in stock1:
						if key1==link['destination']['router']:
							stock1[key1]+=[{link['destination']['interface']:str(address2)}]
				#stockIP[key]+=[{link['destination']['interface']:str(address2)}]
#print (stockIPs)

#1. 遍历路由器：首先，代码遍历`data['routers']`中的每个路由器。对于每个路由器，
#   它在`stockIPs`列表中创建一个以路由器名称为键、空列表为值的字典项。这用于记录每个路由器分配到的IP地址。
#2. 处理网络连接：接着，代码遍历`data['links']`中的每个连接（即网络中路由器之间的链接）。
#   每个连接都包含一个源路由器和目的路由器。
#3. 分配IP地址：对于每个连接，代码从`subnets`（之前生成的子网地址范围）中获取下一个子网地址，
#   并将其分解为两个IP地址（`address1`和`address2`）。然后，它将这些IP地址分配给连接中涉及的路由器接口。
#   这是通过更新`stockIPs`列表中相应的路由器条目来完成的。
#4. 记录分配的地址：分配的IP地址被添加到对应路由器的接口名称下，以便之后生成配置文件时使用。

#1. Traverse routers: First, the code iterates through each router in data['routers']. 
# For each router,it creates a dictionary entry in stockIPs with the router name as the 
# key and an empty list as the value. This is used to record the IP addresses allocated 
# to each router.
#2. Process network connections: Next, the code iterates through each connection in data['links']
# (i.e., the links between routers in the network). Each connection includes a source router and a destination router.
#3. Allocate IP addresses: For each connection, the code retrieves the next subnet address from 
#	subnets (previously generated subnet address range), and breaks it down into two IP addresses
# (address1 and address2). Then, it assigns these IP addresses to the interfaces of the routers 
#  involved in the connection. This is done by updating the corresponding entries in the stockIPs list.
#4. Record the allocated addresses: The allocated IP addresses are added under the respective router's 
#	interface name for later use in generating configuration files.








# 生成loopback地址 distribution les @ loopback
NumOSPF=1
NumLoopback=1
stockLoopbackIP=[]
NumBgp=1
for router in data['routers']:
	stockLoopbackIP+=[{router['name']:str(NumLoopback)+"::"+str(NumLoopback)}]
	NumLoopback+=1

# 这段代码的目的是为每个路由器生成一个唯一的loopback（回环）地址
#1. 初始化变量：`NumOSPF`、`NumLoopback`和`NumBgp`都被初始化为1，`stockLoopbackIP`初始化为空列表。
#	这些变量用于在生成loopback地址时追踪不同的序号。
#2. 遍历路由器：代码遍历`data['routers']`中的每个路由器。
#3. 生成loopback地址：对于每个路由器，代码在`stockLoopbackIP`列表中添加一个字典项。
#	这个字典的键是路由器的名称，值是一个由`NumLoopback`生成的loopback地址（例如"1::1"）。
#	每处理完一个路由器，`NumLoopback`就增加1，以确保每个路由器的loopback地址都是唯一的。
#4. 存储地址：生成的loopback地址存储在`stockLoopbackIP`列表中，以便后续在配置文件中使用。

# The purpose of this code is to generate a unique loopback address for each router.
#1. Initialize variables: `NumOSPF`, `NumLoopback`, and `NumBgp` are all initialized to 1, 
# and `stockLoopbackIP` is initialized as an empty list. These variables are used to track 
# different serial numbers when generating loopback addresses.
#2. Iterate through routers: The code iterates through each router in `data['routers']`.
#3. Generate loopback addresses: For each router, the code adds a dictionary entry in the `stockLoopbackIP` list.
# The key of this dictionary is the router's name, and the value is a loopback address generated by `NumLoopback` (e.g., "1::1").
# After processing each router, `NumLoopback` is incremented to ensure that each router has a unique loopback address.
#4. Store addresses: The generated loopback addresses are stored in the `stockLoopbackIP` list for later use in configuration files.

	
# 创建路由器配置文件 Création d'un fichier de configuration du routeur
for router in data ["routers"]:
	with open(f"{ router['name']}_startup-config.cfg","w") as f:
		f.write("!\n")
		# 编写路由器配置文件头部 the head unchangeable part
		f.write("!\n")
		f.write("!\n")
		f.write("version 15.2\n")
		f.write("service timestamps debug datetime msec\n")
		f.write("service timestamps log datetime msec\n")
		f.write("!\n")
		f.write(f"hostname {router['name']}\n")
		f.write("!\n")
		f.write("boot-start-marker\n")
		f.write("boot-end-marker\n")
		f.write("!\n")
		f.write("!\n")
		f.write("no aaa new-model\n")
		f.write("no ip icmp rate-limit unreachable\n")
		f.write("ip cef\n")
		f.write("!\n")
		f.write("!\n")
		f.write("no ip domain lookup\n")
		f.write("ipv6 unicast-routing\n")
		f.write("ipv6 cef\n")
		f.write("!\n")
		f.write("!\n")
		f.write("multilink bundle-name authenticated\n")
		f.write("!\n")
		f.write("ip tcp synwait-time 5\n")
		f.write("! \n")
		f.write("!\n")
		
		f.write("interface Loopback0\n")
		f.write("no ip address\n")
		
		for loopbackAdd in stockLoopbackIP:
			for key in loopbackAdd:
				if key==router['name']:
					f.write("ipv6 address "+loopbackAdd[key]+"/64\n")
					f.write("ipv6 enable\n")
					if router['protocole']=="OSPF":
						f.write("ipv6 ospf 1 area 0\n")
					if router['protocole']=="RIP":
						f.write("ipv6 rip 1 enable\n")
					f.write("!\n")

# 这段代码是在为每个路由器配置其loopback（回环）接口的IPv6地址和相关的路由协议。
#1. 遍历loopback地址列表：`stockLoopbackIP`列表包含了每个路由器的loopback地址。代码遍历这个列表。
#2. 配置loopback地址：对于匹配当前正在处理的路由器名称的loopback地址，代码会写入配置命令来设置该路由
#	器的loopback接口IPv6地址。
#3. 启用IPv6：通过写入`ipv6 enable`命令，启用该接口的IPv6功能。
#4. 配置路由协议：根据路由器的配置（RIP或OSPF），为该loopback接口配置相应的IPv6路由协议。
#	例如，如果是OSPF协议，则添加命令`ipv6 ospf 1 area 0`，而对于RIP协议，则添加`ipv6 rip 1 enable`。

# This code is configuring IPv6 addresses and related routing protocols for the loopback interfaces of each router.
#1. Iterate through the loopback address list: The stockLoopbackIP list contains the loopback addresses 
# for each router. The code iterates through this list.
#2. Configure loopback address: For the loopback address that matches the name of the router 
# currently being processed, the code writes configuration commands to set the IPv6 address for 
# that router's loopback interface.
#3. Enable IPv6: IPv6 functionality for the interface is enabled by writing the ipv6 enable command.
#4. Configure routing protocol: Depending on the router's configuration (RIP or OSPF), the code 
# configures the corresponding IPv6 routing protocol for the loopback interface.

		# 访问物理接口 accéder dans un interface physique
		for link in data['links']:
			if link['source']['router']==router['name'] or link['destination']['router']==router['name']:

                # 确定邻居路由器
				neighbor_router = link['destination']['router'] if link['source']['router'] == router['name'] else link['source']['router']				
                # 查找邻居路由器的AS号
				neighbor_as = next((r['AS'] for r in data['routers'] if r['name'] == neighbor_router), None)
				
				if link['source']['router']==router['name'] :
					f.write(f"interface {link['source']['interface']}\n")
					f.write(f"no ip address\n")
					f.write(f"negotiation auto\n")
					f.write(f"duplex full\n")
					# 为每个接口配置 @ configurer l'@ pour chaque interface
					for stockIP in stockIPs:
						for key in stockIP:
							if key==router['name']:
								for interface in stockIP[key]:
									for key1 in interface:
									#print(key1)
									#print (link['source']['router'])
										if key1==link['source']['interface']:
										#print('hello')
											f.write(f"ipv6 address {interface[key1]}/64\n")
											
				else:
					f.write(f"interface {link['destination']['interface']}\n")
					f.write(f"no ip address\n")
					f.write(f"negotiation auto\n")
					f.write(f"duplex full\n")
				#f.write(f"ipv6 address ...\n")
					for stockIP in stockIPs:
						for key in stockIP:
							if key==router['name']:
								for interface in stockIP[key]:
									for key1 in interface:
									#print(key1)
									#print (link['source']['router'])
										if key1==link['destination']['interface']:
										#print('hello')
											f.write(f"ipv6 address {interface[key1]}/64\n")
											
				#calculIP(link,f)				
				f.write(f"ipv6 enable \n")
				if (router['protocole']=="RIP"):
					if router['AS'] == neighbor_as:
						f.write("ipv6 rip 1 enable\n")
				if (router['protocole']=="OSPF"):
					#if router['AS'] != neighbor_as:
						#f.write("ipv6 ospf passive\n")					
					f.write("ipv6 ospf 1 area 0\n")
					f.write("!\n")
					f.write("router ospf 1 \n")
					# 假设router['name']是'i8'
					router_id = router['name'].lstrip('i')  # 移除名称中的'i'，留下编号
					router_id_ip = f"{router_id}.{router_id}.{router_id}.{router_id}"  # 生成Router ID
					f.write(f"router-id {router_id_ip}\n")  # 写入配置
					
					f.write("!\n")
				f.write("!\n")

				# 但是这里有个问题，在涉及到6和11连接，或者7和14的连接，
				# 这种涉及到BorderRouter的相互之间的连接的时候，可能会出问题。
				# 在我们的情况中不会，因为他们的端口一个是rip，一个是ospf，
				# 他们直接不会通过IGP通讯，一定会通过BGP通讯。但是如果有另外的网络，
				# 两个不同的AS的IGP都是RIP或者OSPF，他们之间的通讯会使用IGP，而不是BGP了，
				# 这是我们不希望发生的事情。
				# ospf有passive mode。rip需要直接关闭。
				# 这样他们才能通过bgp通讯，而不是rip或者ospf。
				# 那么这里需要检测，这个接口，或者查看这个link的邻居是否是和自己在一个as里。
				# 查看是否是 borderrouter

		#protocole BGP
		f.write(f"router bgp {router['AS']}\n")

# 这段代码负责为每个路由器配置其物理接口的IPv6地址和相关的路由协议。
#1. 遍历路由器的连接：检查每个`link`，如果连接的源或目的路由器是当前处理的路由器，则进行配置。
#2. 配置物理接口：为每个相关的物理接口（无论是作为源还是目的）写入配置命令，包括关闭IPv4地址
#  （`no ip address`），设置协商方式（`negotiation auto`）和全双工模式（`duplex full`）。
#3. 分配IPv6地址：对于每个接口，根据之前分配的IPv6地址进行配置。这是通过在`stockIPs`列表中查
#   找匹配的接口名称并写入相应的`ipv6 address`命令来实现的。
#4. 启用IPv6和配置路由协议：为每个接口启用IPv6（`ipv6 enable`），并根据路由器配置的路由
#   协议（RIP或OSPF）为每个接口添加相应的路由协议配置。
#5. 配置BGP协议：在路由器级别配置BGP协议，包括设置BGP进程ID和与其他BGP邻居的关系。

# This code is responsible for configuring IPv6 addresses and related routing protocols 
# for the physical interfaces of each router.
#1. Iterate through router's connections: It checks each `link`, and if the source or 
# destination router of the connection matches the currently processed router, it proceeds 
# with the configuration.
#2. Configure physical interfaces: Configuration commands are written for each relevant 
# physical interface (whether it's the source or destination). These commands include disabling
#  IPv4 address (`no ip address`), setting negotiation mode (`negotiation auto`), and configuring full-duplex mode (`duplex full`).
#3. Assign IPv6 addresses: For each interface, configuration is done based on previously assigned
#  IPv6 addresses. This is achieved by finding a matching interface name in the `stockIPs` list 
# and writing the corresponding `ipv6 address` command.
#4. Enable IPv6 and configure routing protocols: IPv6 is enabled for each interface 
# (`ipv6 enable`), and routing protocol configurations are added to each interface based on
#  the router's configured routing protocol (RIP or OSPF).
#5. Configure BGP protocol: BGP protocol is configured at the router level, including setting 
# the BGP process ID and establishing relationships with other BGP neighbors.
		
		
		#####################################################################################
		f.write("bgp router-id "+str(NumBgp)+"."+str(NumBgp)+"."+str(NumBgp)+"."+str(NumBgp)+"\n")
		#####################################################################################
		NumBgp+=1
		
		f.write("bgp log-neighbor-changes\n")
		f.write("no bgp default ipv4-unicast\n")		
		for router1 in data['routers']:
			if router1['AS']==router['AS'] and router1['name']!=router['name']:
				#f.write("neighbor "+str(NumLoopback)+"::"+str(NumLoopback)+"\n")
				for loopbackIP in stockLoopbackIP:
					for key in loopbackIP:
						if router1['name']==key:
							f.write("neighbor "+loopbackIP[key]+" remote-as "+router['AS']+"\n")
							f.write("neighbor "+loopbackIP[key]+" update-source loopback0\n")
		#configuration d'EBGP
		if router['BorderRouter']==True:
			for link in data['links']:
				if link['source']['router']==router['name']:
					routerNeighbor=link['destination']['router']
					interfaceNeighbor=link['destination']['interface']
					for IP in stockIPs:
						for key in IP:
							if key==routerNeighbor:
								for inter in IP[key]:
									for key1 in inter:
										if key1==interfaceNeighbor:
											#inter[key1]
											for router1 in data['routers']:
												#print(key1)
												if router1['name']==routerNeighbor:
													#router1['AS']
													
													f.write("neighbor "+inter[key1]+" remote-as "+router1['AS']+"\n")
				elif link['destination']['router']==router['name']:
					routerNeighbor=link['source']['router']
					interfaceNeighbor=link['source']['interface']
					for IP in stockIPs:
						for key in IP:
							if key==routerNeighbor:
								for inter in IP[key]:
									for key1 in inter:
										if key1==interfaceNeighbor:
											#inter[key1]
											for router1 in data['routers']:
												#print(key1)
												if router1['name']==routerNeighbor:
													#router1['AS']
													
													f.write("neighbor "+inter[key1]+" remote-as "+router1['AS']+"\n")
				
# 这段代码负责配置BGP（边界网关协议）的相关设置：
#1. 设置BGP路由器ID：使用`NumBgp`变量生成一个唯一的BGP路由器ID。这通常是一个类似于IP地址的唯一标识符。
#2. 记录邻居变化：通过`bgp log-neighbor-changes`命令记录BGP邻居的变化情况。
#3. 关闭默认IPv4单播：使用`no bgp default ipv4-unicast`命令关闭默认的IPv4单播，这通常用于IPv6网络。
#4. 配置IBGP邻居：遍历同一自治系统（AS）内的其他路由器，并为它们设置IBGP（内部BGP）邻居关系。
#	利用loopback地址进行邻居配置，确保稳定的连接。
#5. 配置EBGP邻居：如果当前路由器是边界路由器（`BorderRouter`为`True`），
#	则遍历所有连接并为与其他AS的连接设置EBGP（外部BGP）邻居关系。

# This code is responsible for configuring the settings related to BGP (Border Gateway Protocol):
#1. Set BGP Router ID: A unique BGP Router ID is generated using the `NumBgp` variable. 
# This typically serves as a unique identifier similar to an IP address.
#2. Log Neighbor Changes: It logs changes in BGP neighbors' status using the `bgp log-neighbor-changes` command.
#3. Disable Default IPv4 Unicast: The `no bgp default ipv4-unicast` command is used to disable 
# the default IPv4 unicast behavior, which is often used in IPv6 networks.
#4. Configure IBGP Neighbors: It iterates through other routers within the same Autonomous System
#  (AS) and sets up IBGP (Internal BGP) neighbor relationships with them. Loopback addresses are 
# utilized for neighbor configurations to ensure stable connections.
#5. Configure EBGP Neighbors: If the current router is a border router 
# (`BorderRouter` is set to `True`), it iterates through all connections and establishes EBGP
#  (External BGP) neighbor relationships with routers in other ASs.
		
		f.write("!\n")
		f.write("address-family ipv4\n")
		f.write("exit-address-family\n")
		f.write("!\n")
		f.write("address-family ipv6\n")
		for IP in stockIPs:
			for key in IP:
				if key==router['name']:
					for inter in IP[key]:
						for key1 in inter:
							f.write(" network "+inter[key1][:-1]+"/64\n")	
		f.write("!\n")
		for router1 in data['routers']:
			if router1['AS']==router['AS'] and router1['name']!=router['name']:
				#f.write("neighbor "+str(NumLoopback)+"::"+str(NumLoopback)+"\n")
				for loopbackIP in stockLoopbackIP:
					for key in loopbackIP:
						if router1['name']==key:
							f.write("neighbor "+loopbackIP[key]+" activate "+"\n")
		if router['BorderRouter']==True:
			for link in data['links']:
				if link['source']['router']==router['name']:
					routerNeighbor=link['destination']['router']
					interfaceNeighbor=link['destination']['interface']
					for IP in stockIPs:
						for key in IP:
							if key==routerNeighbor:
								for inter in IP[key]:
									for key1 in inter:
										if key1==interfaceNeighbor:
											#print(inter[key1])					
											f.write("neighbor "+inter[key1]+" activate"+"\n")
				elif link['destination']['router']==router['name']:
					routerNeighbor=link['source']['router']
					interfaceNeighbor=link['source']['interface']
					for IP in stockIPs:
						for key in IP:
							if key==routerNeighbor:
								for inter in IP[key]:
									for key1 in inter:
										if key1==interfaceNeighbor:
											#print(inter[key1])					
											f.write("neighbor "+inter[key1]+" activate"+"\n")			
							
# 这段代码主要处理BGP的IPv6地址族配置：
#1. IPv4地址族配置：定义了IPv4地址族的部分。
#2. IPv6地址族配置：声明了`address-family ipv6`。
#3. 网络广播：遍历所有接口IP地址，将它们添加到BGP网络广播中，这样BGP邻居可以了解这些网络。
#4. 激活IBGP邻居：在IPv6地址族中激活之前设置的IBGP邻居。
#5. 激活EBGP邻居：如果路由器是边界路由器，为其EBGP连接的邻居在IPv6地址族中设置激活状态。
# 这样，BGP配置就可以支持IPv6网络，允许路由器在其自治系统内部及与其他AS之间有效地交换IPv6路由信息。							
							
# This code primarily deals with the configuration of the IPv6 address family for BGP (Border Gateway Protocol):
#1. IPv4 Address Family Configuration: It defines a portion of the configuration for the IPv4 address family.
#2. IPv6 Address Family Configuration: It declares the `address-family ipv6`.
#3. Network Advertisement: It iterates through all interface IP addresses and adds them to
#  BGP network advertisements, allowing BGP neighbors to learn about these networks.
#4. Activate IBGP Neighbors: It activates the previously configured IBGP neighbors within the IPv6 address family.
#5. Activate EBGP Neighbors: If the router is a border router, it activates the neighbors for 
# its EBGP connections within the IPv6 address family.
# This configuration enables BGP to support IPv6 networks, allowing routers to effectively 
# exchange IPv6 routing information within their Autonomous System and with other ASs.							
							
							
		f.write("exit-address-family\n")
		f.write("!\n")
		f.write("ip forward-protocole nd\n")
		f.write("!\n")
		f.write("!\n")
		f.write("no ip http server\n")
		f.write("no ip http secure-server\n")
		
		
		f.write("!\n")
		#protocole IGP
		if (router['protocole']=="RIP"):
			f.write("ipv6 router rip 1\n")
			f.write("redistribute connected\n")
		if (router['protocole']=="OSPF"):
			f.write(f"!\n")
			f.write("ipv6 router ospf 1 \n")					
			f.write("router-id "+ str(NumOSPF)+"."+str(NumOSPF)+"."+str(NumOSPF)+"."+str(NumOSPF)+"\n")	
			NumOSPF+=1
		f.write(f"!\n")
		#仍然可以加一些BGP的配置在这里

#1. 退出地址族配置：`exit-address-family`标记着IPv6地址族配置的结束。
#2. 禁用HTTP服务：`no ip http server`和`no ip http secure-server`命令
#禁用了HTTP和HTTPS服务，增加了设备的安全性。
#3. 配置IGP（内部网关协议）：根据路由器配置的协议（RIP或OSPF），添加了
#相应的IGP配置。对于RIP，启用了RIP协议并允许重分发已连接网络。对于OSPF，启用了
#OSPF协议并设置了路由器ID。

#1. Exit Address Family Configuration: `exit-address-family` marks the end 
# of the IPv6 address family configuration.
#2. Disable HTTP Services: The commands `no ip http server` and `no ip http secure-server` disable
#  HTTP and HTTPS services, enhancing the device's security.
#3. Configure IGP (Interior Gateway Protocol): Based on the router's configured protocol (RIP or 
# OSPF), the corresponding IGP configurations are added. For RIP, the RIP protocol is enabled, and
#  redistribution of connected networks is allowed. For OSPF, the OSPF protocol is enabled, and a router ID is set.


				
		#the end unchangeable part
		f.write("!\n")
		f.write("control-plane\n")
		f.write("!\n")
		f.write("!\n")
		f.write("line con 0\n")
		f.write(" exec-timeout 0 0\n")
		f.write(" privilege level 15\n")
		f.write(" logging synchronous\n")
		f.write(" stopbits 1\n")
		f.write("line aux 0\n")
		f.write(" exec-timeout 0 0\n")
		f.write(" privilege level 15\n")
		f.write(" logging synchronous\n")
		f.write(" stopbits 1\n")
		f.write("line vty 0 4\n")
		f.write(" login\n")
		f.write("!\n")
		# 在配置文件的末尾部分加入结束命令
		f.write("!\n")
		f.write("end\n")
		
		# 移动配置文件到指定目录 déplacer le fichier
		dossier="C:/Users/Utilisateur/Desktop/GNS2" # GNS3项目目录 répertoire de projet GNS3 
		liste_dossiers=os.listdir(dossier)
		#time.sleep(5)
		for nom_dossier in liste_dossiers:
			
			if os.path.isdir(os.path.join(dossier,nom_dossier)):
				listes=os.listdir(dossier+"/"+f"{nom_dossier}"+"/configs")#répertoire de dossier "configs"
				for liste in listes:
		 			#print(f"{router['name']}_startup-config.cfg")
		 			if liste==f"{router['name']}_startup-config.cfg":
		 				path=os.replace("/home/tangkeke/Documents/GNS/"+f"{ router['name']}_startup-config.cfg",dossier+"/"+f"{nom_dossier}"+"/configs/"+f"{router['name']}_startup-config.cfg")#le premier élément est la répertoire de script Python, le deuxième est la répertoire de ".cfg"
 